- [1 正则表达式的概念和作用](#1-正则表达式的概念和作用)
- [2 正则表达式的规则](#2-正则表达式的规则)
  - [2.1 字面量字符和元字符](#21-字面量字符和元字符)
  - [2.2 特殊字符：无法打印的字符](#22-特殊字符无法打印的字符)
  - [2.3 修饰符](#23-修饰符)
  - [2.4 预定义模式：预定义好的一些字符模式](#24-预定义模式预定义好的一些字符模式)
  - [2.5 非贪婪模式](#25-非贪婪模式)
  - [2.6 组匹配](#26-组匹配)
    - [(1) 捕获组()](#1-捕获组)
    - [（2）非捕获组(?:x)](#2非捕获组x)
    - [（3）先行断言x(?=y)](#3先行断言xy)
    - [（4）先行否定断言x(?!y)](#4先行否定断言xy)
- [3 js中的正则表达式API](#3-js中的正则表达式api)
  - [3.1 创建正则表达式](#31-创建正则表达式)
  - [3.2 正则对象的实例属性和方法](#32-正则对象的实例属性和方法)
## 1 正则表达式的概念和作用
正则表达式相当于字符串模板，用来搜索和匹配字符串的，它作为程序员的一项基本功，在日常开发中非常常用
## 2 正则表达式的规则
### 2.1 字面量字符和元字符
- 字面量字符：顾名思义，代表字符本身，如'abc'
- 元字符：可以理解成通配符
  - 点字符`.`:匹配除回车\r，换行\n，行分隔符，段分隔符外的所有码点不超过0xFFFF的字符
  - 位置字符
    - `^`:表示字符串开始的位置
    - `$`:表示字符串结束的位置
  - 选择符`|`:或的含义
  - 字符类`[]`：匹配可选系列字符中的一个,如`[abc]`，在`[]`里面有两个具有特殊含义的字符（脱字符`^`和连字符`-`，分别表示取反和连续的意思）
  - 重复类`{}`: `{n}`表示可重复n次，`{n,m}`表示可重复n~m次
  - 量词符：用来设定某个模式出现的次数
    - `*`:匹配任意个，相当于`{0, }`
    - `?`:匹配至多1个,相当于`{0, 1}`
    - `+`:匹配至少1个,相当于`{1, }`
  - 转义符`\`：要表示元字符本身，需要使用反斜杠`\`对元字符进行转义
### 2.2 特殊字符：无法打印的字符
  - `\n`:匹配换行键
  - `\r`:匹配回车键
  - `\t`:匹配制表符
  - `\v`:匹配垂直制表符
  - `\f`:匹配换页符
  - `\0`:匹配null字符(U+0000)
  - `\uhhhh`:匹配以4位16进制数表示的Unicode字符
  - ...
### 2.3 修饰符
  - i修饰符：忽略大小写
  - g修饰符：全局匹配
  - m修饰符：多行模式，会修改`^`和`$`的含义，使`^`不仅具有字符串开始还具有行首的含义，`$`同理，增加了行尾的含义
### 2.4 预定义模式：预定义好的一些字符模式
  - `\d`:匹配单个数字0-9
  - `\D`:匹配非`\d`,相当于`[^0-9]`
  - `\w`:匹配单个数字、字母或下划线,相当于`[0-9a-zA-Z_]`
  - `\W`:匹配非`\w`
  - `\s`:匹配空白符（包括换行符、制表符、空格符等），相当于`[ \r\n\t\v\f]`
  - `\S`:匹配非`\s`, 通常用`\S\s`指代一切字符
  - `\b`:匹配词的边界（由空格、-、.等(不包括_)分隔）
  - `\B`:匹配非`\b`
### 2.5 非贪婪模式
  量词符`*`,`+`,`?`默认是贪婪模式（尽可能多地匹配），在其后面再加一个`?`（`*?`,`+?`,`??`）表示非贪婪模式（尽可能少地匹配）
e.g.
```js
`abb`.match(/ab*/) // ["abb"]
`abb`.match(/ab*?/) // ["a"]
`abb`.match(/ab?/) // ["ab"]
`abb`.match(/ab??/) // ["a"]
```
### 2.6 组匹配
#### (1) 捕获组()
正则表达式中括号表示分组匹配，括号中的模式可以用来匹配分组的内容
e.g.1
```js
/fred+/.test("fredd") // true
/(fred)+/.test("fredfred") //true
```
e.g.2
```js
var m= 'abcabc'.match(/(.)b(.)/) // ['abc', 'a', 'c']
```

注意使用组匹配时，不宜同时使用g修饰符，否则match方法不会捕获分组内容，如果实在需要同时使用g修饰符，解决办法是使用exec并进行循环匹配
e.g.3
```js
var m= 'abcabc'.match(/(.)b(.)/g) // ['abc', 'abc']
```
正则表达式内部，还可使用`\n`引用括号内部的内容
e.g.4
```js
/(.)b(.)\1b\2/.test("abcabc") // true
```
#### （2）非捕获组(?:x)
`(?:x)`表示不返回该组匹配的内容，即匹配的结果中不计入这个括号
#### （3）先行断言x(?=y)
`x(?=y)`表示x只有在y前面才匹配，y不会计入返回的结果，比如要匹配后面跟着百分号的数字，可写成`/\d+(?=%)/`
#### （4）先行否定断言x(?!y)
`x(?!y)`表示x只有不在y前面才匹配，y不会计入返回的结果
## 3 js中的正则表达式API
js的正则表达式参照Perl5建立
### 3.1 创建正则表达式
1. 利用`//`字面量创建，可在第2个`/`后包含i(忽略大小写)、g(全局匹配)、m（多行匹配）等修饰符
2. 利用`new RegExp(str[, modifier])`构造函数创建,str为正则表达式字符串，第二个参数为修饰符字符串
ps: 两种创建方法等价，主要区别是第一种js引擎在编译时就会新建正则表达式，而第二种在运行时才会新建，所以第一种效率更高也更直观
### 3.2 正则对象的实例属性和方法
1. 实例属性
  - 修饰类：RegExp.prototype.ignoreCase，RegExp.prototype.global, RegExp.prototype.multiline分别表示是否设置了i、g、m修饰符，RegExp.prototype.flags返回设置的修饰符字符串
  - 修饰符无关属性：RegExp.prototype.lastIndex和RegExp.prototype.source，分别表示下一次匹配的位置和正则表达式字符串
2. 实例方法
  - RegExp.prototype.test(str)：返回布尔值，表示当前模式是否能匹配参数字符串，如果带有`g`修饰符，则会进行多次匹配（每次从lastIndex开始）
  - RegExp.prototype.exec(str)：匹配到则返回匹配的结果数组，未匹配到则返回空。如果正则表达式含有圆括号（组匹配），则结果数组第一个元素是当次匹配的字符串，剩下的元素是各组匹配的字符串。返回的结果数组还包含2个属性：index（模式匹配成功的开始位置）和input（原参数字符串）
3. 字符串的实例方法
  - `String.prototype.match(RegExp)`：返回数组，成员是所有匹配成功的子字符串，类似正则对象的exec方法，但含有g修饰符时会一次返回全部匹配的结果，而exec方法则需要执行多次
  - `String.prototype.search(RegExp)`：按照正则表达式搜索，返回匹配成功的开始位置，没有匹配则返回-1
  - `String.prototype.replace(search, replacement)`：按照给定的字符串或正则表达式搜索，并用replacement替换搜索到的部分，返回替换后的字符串，第二个参数还可使用`$`符或函数`function(matchedStr, $1, $2,...,$n[,index, input])`，分别用来指代所替换的内容或将搜索结果替换为函数的返回值。
    - `$&`:匹配的子字符串
    - `$n`:匹配成功的第n组内容
    - $`:匹配结果前面的文本
    - `$'`:匹配结果后面的文本
    - `$$`:指代$本身
  - `String.prototype.split(seperate[, limit])`：按照给定的字符串或正则表达式分割，返回分割后的数组，limit可指定返回数组的最大成员数。